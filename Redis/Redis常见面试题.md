## 储存结构和使用场景
- `string` 字符串、数字，一些简单的k-v数据
- `list` 数组、集合，简单消息队列（缺点很多，比如不能重复消费，不能多订阅，无"消息持久化"，无确认机制）
- `hash` 储存对象
- `set` 不可重复数据、做交并集的数据
- `zset` 排序的不可重复数据，比如 一个直播间的礼物排行榜

## 淘汰策略
1. `noeviction`：当内存不足以容纳新写入数据时，新写入操作会报错。
2. `allkeys-lru`：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。
3. `allkeys-random`：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
4. `volatile-lru`：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
5. `volatile-random`：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
6. `volatile-ttl`：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

## AOF文件很大怎么办
执行 BGREWRITEAOF 命令，对AOF文件重写

## 为什么Redis使用跳表，不使用红黑树或B+树

Redis 使用跳表的原因

Redis 在实现有序集合（ZSet）时，使用的是跳表（SkipList），而没有选择红黑树或 B+ 树。

### 2.1 跳表的优点

- 实现简单：跳表的结构相对简单，使用多级索引进行加速。虽然在理想情况下，它的时间复杂度和红黑树相同，都是 O(log n)，但跳表的实现代码简单且直观，插入和删除也较为轻量级。
- 支持区间查询：Redis 使用的跳表结构特别适合范围查询，跳表允许快速的从某个节点开始进行逐步遍历，非常适合 Redis 中经常需要的范围查询操作（如查找某个分数范围内的所有元素）。
- 顺序性：跳表天然是有序的，Redis 的有序集合要求能够对元素按照分数进行排序并保持有序，这一要求跳表可以很好地满足。
### 2.2 为什么不使用红黑树？
- 红黑树的复杂性：红黑树的实现虽然也能保证 O(log n) 的时间复杂度，但插入、删除和调整平衡的逻辑相对复杂，特别是在 Redis 这种高性能、实时要求的系统中，代码简洁和可维护性很重要。跳表在处理区间查询时的遍历逻辑比红黑树更直观。
- 区间操作性能：红黑树虽然可以通过中序遍历实现区间查询，但性能和跳表相比，略显不足。跳表从某个节点可以直接开始线性扫描，而红黑树需要从根节点逐步找到起始点，跳表在这方面有天然优势。
### 2.3 为什么不选择 B+ 树？
- B+ 树适合磁盘存储：和 HashMap 类似，B+ 树在内存中的查找效率并不如跳表。B+ 树的节点结构复杂，维护成本高，且 Redis 是基于内存的数据库系统，不需要像 B+ 树那样通过层次结构优化磁盘 I/O。
- Redis 的简单高效设计理念：Redis 追求的是极简和高效，而跳表比 B+ 树的实现简单，操作也更加高效。

总结：

- Redis 选择跳表：跳表的实现简单，支持快速区间查询，非常适合 Redis 中有序集合的场景需求。相比红黑树，跳表在遍历和范围查询中表现更优，而相比 B+ 树，跳表的内存使用更加轻量级，更加适合 Redis 的内存结构。
##  Redis如何做内存优化？

*  **控制key的数量**。当使用Redis存储大量数据时，通常会存在大量键，过多的键同样会消耗大量内存。Redis本质是一个数据结构服务器，它为我们提供多种数据结构，如hash，list，set，zset 等结构。使用Redis时不要进入一个误区，大量使用get/set这样的API，把Redis当成Memcached使用。对于存储相同的数据内容利用Redis的数据结构降低外层键的数量，也可以节省大量内存。

*  **缩减键值对象**，降低Redis内存使用最直接的方式就是缩减键（key）和值（value）的长度。

   - key长度：如在设计键时，在完整描述业务情况下，键值越短越好。
   - value长度：值对象缩减比较复杂，常见需求是把业务对象序列化成二进制数组放入Redis。首先应该在业务上精简业务对象，去掉不必要的属性避免存储无效数据。其次在序列化工具选择上，应该选择更高效的序列化工具来降低字节数组大小。

*  **编码优化**。Redis对外提供了string,list,hash,set,zet等类型，但是Redis内部针对不同类型存在编码的概念，所谓编码就是具体使用哪种底层数据结构来实现。编码不同将直接影响数据的内存占用和读写效率。可参考文章：https://cloud.tencent.com/developer/article/1162213


##  如果现在有个读超高并发的系统，用Redis来抗住大部分读请求，你会怎么设计？

如果是读高并发的话，先看读并发的数量级是多少，因为Redis单机的读QPS在万级，每秒几万没问题，使用一主多从+哨兵集群的缓存架构来承载每秒10W+的读并发，主从复制，读写分离。

使用哨兵集群主要是提高缓存架构的可用性，解决单点故障问题。主库负责写，多个从库负责读，支持水平扩容，根据读请求的QPS来决定加多少个Redis从实例。如果读并发继续增加的话，只需要增加Redis从实例就行了。

如果需要缓存1T+的数据，选择Redis cluster模式，每个主节点存一部分数据，假设一个master存32G，那只需要n*32G>=1T，n个这样的master节点就可以支持1T+的海量数据的存储了。

> Redis单主的瓶颈不在于读写的并发，而在于内存容量，即使是一主多从也是不能解决该问题，因为一主多从架构下，多个slave的数据和master的完全一样。假如master是10G那slave也只能存10G数据。所以数据量受单主的影响。
> 而这个时候又需要缓存海量数据，那就必须得有多主了，并且多个主保存的数据还不能一样。Redis官方给出的 Redis cluster 模式完美的解决了这个问题。